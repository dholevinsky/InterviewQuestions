// reverse list
func reverseList(head: SingleListNode?) -> SingleListNode? {
    var newHead: SingleListNode? = nil
    var inputHead = head
    
    while inputHead != nil {
        inputHead?.next = newHead
        newHead = inputHead
        inputHead = inputHead?.next
    }
    
    return newHead
}

// middle node
func middleNode(head: SingleListNode?) -> SingleListNode? {
    var walker = head
    var runner = head
    
    while runner != nil && runner?.next != nil {
        runner = runner?.next?.next
        walker = walker?.next
    }
    
    return walker
}

// delete duplicates in a sorted linked list
func deleteDuplicatesInSorted(_ head: SingleListNode?) -> SingleListNode? {
    var newHead = head
    
    while newHead?.next != nil {
        if newHead?.value == newHead?.next?.value {
            newHead?.next = newHead?.next?.next
        } else {
            newHead = newHead?.next
        }
    }
    return newHead
}

// delete duplicates in an unsorted linked list
func deleteDuplicates(head: SingleListNode?) -> SingleListNode? {
    var set = Set<Int>()
    
    var prev: SingleListNode? = nil
    var inputHead = head
    
    while inputHead != nil {
        if set.contains((head?.value)!) {
            prev?.next = inputHead?.next
        } else {
            set.insert((inputHead?.value)!)
            prev = inputHead
        }
        inputHead = inputHead?.next
    }
    return inputHead
}

// check if a linked list has a cycle
func hasCycle(head: SingleListNode?) -> Bool {
    if head == nil {
        return false
    }
    
    var walker = head
    var runner = head
    
    while runner?.next != nil && runner?.next?.next != nil {
        walker = walker?.next
        runner = runner?.next?.next
        if walker === runner { //might be walker == runner
            return true
        }
    }
    return false
}

// merge two linked lists
func mergeTwoLists(_ l1: SingleListNode?, _ l2: SingleListNode?) -> SingleListNode? {
    if l1 == nil {
        return l2
    }
    
    if l2 == nil {
        return l1
    }
    
    var newHead: SingleListNode?
    
    if (l1?.value)! < (l2?.value)! {
        newHead = l1
        newHead?.next = mergeTwoLists(l1?.next, l2)
    } else {
        newHead = l2
        newHead?.next = mergeTwoLists(l2?.next, l1)
    }
    
    return newHead
}

// insert a node into a sorted linked list
func insert(head: SingleListNode?, node: SingleListNode) -> SingleListNode? {
    if head == nil || (head?.value)! > node.value {
        node.next = head
        return node
    }
    
    var currentNode = head
    
    while currentNode != nil && (currentNode?.next?.value)! < node.value {
        currentNode = currentNode?.next
        
        node.next = currentNode?.next
        currentNode?.next = node
    }
    
    return head
}

// find the nth to last node
func nthToLast(head: SingleListNode?, n: Int) -> SingleListNode? {
    if head == nil || n < 1 {
        return nil
    }
    
    var p1 = head
    var p2 = head
    
    for _ in 1..<n-1 {
        if p2 == nil {
            return nil
        }
        
        p2 = p2?.next
        
        while p2 != nil {
            p1 = p1?.next
            p2 = p2?.next
        }
    }
    
    return p1
}
